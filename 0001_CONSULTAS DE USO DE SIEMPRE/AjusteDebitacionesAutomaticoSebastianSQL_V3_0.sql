--
-- SELECT INUMEROTARJETA, count(1) FROM SINCRONIZADOR.AJUSTEDEB WHERE BPROCESADO = 0  group by INUMEROTARJETA;


-- SELECT * FROM SINCRONIZADOR.AJUSTEDEB WHERE BPROCESADO = 0;
-- select count(1) from SINCRONIZADOR.AJUSTEDEB where bProcesado = 0 AND sincidencia like 'SIM.%';
-- select count(1) from SINCRONIZADOR.AJUSTEDEB where bProcesado = 0 and sincidencia not like 'SIM.%';
-- INSER DEBITACIONES PENDIENTES PARA CUADRAR SALDOS MON
--SE OBTIENE LA PRIMER INFO, DEL GRUPO DE TARJETAS PROPORCIONADO, DETERMINAR CUANTAS DEBITACIONES NECESITAS CUANTAS ENTERAS Y CUANTOS TRANSBORDOS, SOLO SI SON LOS MISMOS LTCS ENTRAN EN LA TARJETA,
--SE EVALUA EL ULTIMO REGISTRO DEL SALDO DE NFC DE TARJETA CONTRA EL DEL MONEDERO DE ESTADO DE CUENTA
 INSERT INTO SINCRONIZADOR.AJUSTEDEB (UIDDETALLESINCRONIZADOR, DTFECHAOPERACION, INUMEROTARJETA,STIPOTARIFA, DMONTOCOBRADO, SALDOMON,DSALDO, ICONTADORTRANSACCIONES,DTFECHACREACION,LOADTRANSCOUNTER, IERROR,BPROCESADO, FECHAPROCESADO,NVAFECHAPROCESAR,TRANSBORDO,SINCIDENCIA,NVODMONTOCOBRADO,BERROR)
WITH base AS (
    SELECT *
    FROM (
        SELECT
            t1.INUMEROTARJETA,
            t3.ICONTADORRECARGA,
            t3.ICONTADORRECARGAAPLICADA,
            t1.DSALDO,
            t2.DSALDO AS DSALDO_ESTADOCUENTA,
            ((t1.DSALDO * -1) + t2.DSALDO) AS SaldoDebitar,
            ROUND(((t1.DSALDO * -1) + t2.DSALDO) / (CASE WHEN t2.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END), 0) AS NUMDEBITACIONES,
            TRUNC(((t1.DSALDO * -1) + t2.DSALDO) / (CASE WHEN t2.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END)) AS PARTE_ENTERA,
            (((t1.DSALDO * -1) + t2.DSALDO) / (CASE WHEN t2.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END))
                - TRUNC(((t1.DSALDO * -1) + t2.DSALDO) / (CASE WHEN t2.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END)) AS PARTE_DECIMAL,
            t1.DTFECHAOPERACION,
            ROW_NUMBER() OVER (PARTITION BY t1.INUMEROTARJETA ORDER BY t1.DTFECHAOPERACION DESC) AS RN
        FROM SINCRONIZADOR.DETALLESINCRONIZACIONTRANSACCIONESNFC t1
        JOIN MONEDEROCONSULTAS.ESTADODECUENTA t2 ON t1.INUMEROTARJETA = t2.INUMTARJETA
        JOIN SINCRONIZADOR.MONEDERO t3 ON t3.INUMEROTARJETA = t1.INUMEROTARJETA
        WHERE t3.ICONTADORRECARGA = t3.ICONTADORRECARGAAPLICADA
        ---MAS ADELANTE HAY QUE COLOCAR ACA TAMBIEN LOS QUE
        AND  T1.SINCIDENCIA not like 'DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN REPROCESOS
        AND  T1.SINCIDENCIA not like 'SIM. DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN REPROCESOS

          AND t1.INUMEROTARJETA IN (
          --PONER TARJETAS AQUI SEPARADAS POR COMAS
 5000000000624201
          )
    )
    WHERE RN = 1
)
--select * from base;
,
---CONDICIONES ORIGIALNES EL PRIMER SCRIPT DE AJUSTES
base_raw AS (
    SELECT
        base.NUMDEBITACIONES,
        base.PARTE_ENTERA,
        base.PARTE_DECIMAL,
        ROW_NUMBER() OVER (PARTITION BY nfc.INUMEROTARJETA ORDER BY nfc.DTFECHAOPERACION DESC) AS ID,
        nfc.*
    FROM SINCRONIZADOR.DETALLESINCRONIZACIONTRANSACCIONESNFC nfc
    JOIN base ON nfc.INUMEROTARJETA = base.INUMEROTARJETA
    WHERE nfc.IERROR != 0
      --AND nfc.ITRANSBORDO = 0
      AND nfc.UIDDETALLESINCRONIZADOR NOT IN (
            SELECT UIDDETALLESINCRONIZADOR FROM SINCRONIZADOR.AJUSTEDEB
      )
      AND nfc.DTFECHAOPERACION < SYSDATE - 3 --> AQUI ES DE CUANTOS DIAS PARA ATRAS CONSIDERAR LOS REGISTROS DIFERNTES A ERROR 0 PARA TOMARLOS
            AND  SINCIDENCIA not like 'DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN REPROCESOS
            AND  SINCIDENCIA not like 'SIM. DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN SIMULADOS DE REPROCESOS
)

--select * from base_raw;
,
---ELEGIR UN REGISTRO POR DIA PARA EVITAR REPETIR VALIDADORES
sin_repetir_validadores AS (
    SELECT *
    FROM (
        SELECT
            r.*,
            ROW_NUMBER() OVER (
                PARTITION BY r.INUMEROTARJETA, TRUNC(r.DTFECHACREACION)
                ORDER BY r.UIDDETALLESINCRONIZADOR
            ) AS RN
        FROM base_raw r
    )
    WHERE RN = 1
    --select * from base_raw;
),
--RECALCULADOS LOS INDICES DE ID CON EL CAMPO NEWID PARA OCUPARLO DENTRO DE LA VALIDACION DE TARJETAS CON EL NUMERO DE DEBITACIONES EXACTAS
Recalculando_identificadores as(
           select
                        (ROW_NUMBER() OVER (PARTITION BY srv.INUMEROTARJETA ORDER BY srv.DTFECHAOPERACION DESC)) AS NewID,
             srV.*
             from sin_repetir_validadores srv
)
--select * from Recalculando_identificadores  order by NewID asc;
,
tarjetas_validas AS (
    SELECT INUMEROTARJETA
    FROM Recalculando_identificadores
    WHERE NewID <= NUMDEBITACIONES
    and 1=0
    GROUP BY INUMEROTARJETA, NUMDEBITACIONES
    HAVING COUNT(*) = NUMDEBITACIONES
),
--Reconocer cuales tarjetas no cumplieron con el numero de debitaciones necesarias para entrar a la alternativa de usar registros correctos empezando desde el primero que ha tenido.
tarjetas_NO_validas AS (
SELECT INUMEROTARJETA FROM base WHERE INUMEROTARJETA NOT IN(
    SELECT INUMEROTARJETA
    FROM Recalculando_identificadores
    WHERE NewID <= NUMDEBITACIONES
    and 1=0
    GROUP BY INUMEROTARJETA, NUMDEBITACIONES
    HAVING COUNT(*) = NUMDEBITACIONES
--    HAVING COUNT(*) != NUMDEBITACIONES
    )
)
--select * from tarjetas_NO_validas;
,
--CTA PARA OBTENER EL NUEVO NUMERO DE REGISTROS INCLUYENDO REGISTROS QUE SON CORRECTOS
base_raw_REPETIDOS_REGISTROS_BIEN_INCLUYENDO_PRIMERO_LOS_MALOS AS (
    select *
    from (
--                    SELECT
--                    base.NUMDEBITACIONES,
--                    base.PARTE_ENTERA,
--                    base.PARTE_DECIMAL,
--                    ROW_NUMBER() OVER (PARTITION BY nfc.INUMEROTARJETA ORDER BY nfc.DTFECHAOPERACION asc) AS ID,
--                    nfc.*
--                FROM SINCRONIZADOR.DETALLESINCRONIZACIONTRANSACCIONESNFC nfc
--                JOIN base ON nfc.INUMEROTARJETA = base.INUMEROTARJETA
--                join  tarjetas_NO_validas on base.INUMEROTARJETA = tarjetas_NO_validas.INUMEROTARJETA
--                WHERE nfc.IERROR !=0
--                  --AND nfc.ITRANSBORDO = 0
--                  AND nfc.UIDDETALLESINCRONIZADOR NOT IN (
--                        SELECT UIDDETALLESINCRONIZADOR FROM SINCRONIZADOR.AJUSTEDEB
--                  )
--                  AND nfc.DTFECHAOPERACION < SYSDATE - 3 --> AQUI ES DE CUANTOS DIAS PARA ATRAS CONSIDERAR LOS REGISTROS DIFERNTES A ERROR 0 PARA TOMARLOS
--                  AND  nfc.SINCIDENCIA not like 'DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN REPROCESOS
--            AND  nfc.SINCIDENCIA not like 'SIM. DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN SIMULADOS DE REPROCESOS
--                  UNION
                      ---Aqui metemos el union para poder tener tambien el de los errores y el de los buenos

                SELECT
                    base.NUMDEBITACIONES,
                    base.PARTE_ENTERA,
                    base.PARTE_DECIMAL,
                    ROW_NUMBER() OVER (PARTITION BY nfc.INUMEROTARJETA ORDER BY nfc.DTFECHAOPERACION asc) AS ID,
                    nfc.*
                FROM SINCRONIZADOR.DETALLESINCRONIZACIONTRANSACCIONESNFC nfc
                JOIN base ON nfc.INUMEROTARJETA = base.INUMEROTARJETA
                join  tarjetas_NO_validas on base.INUMEROTARJETA = tarjetas_NO_validas.INUMEROTARJETA
                WHERE nfc.IERROR =0
                  --AND nfc.ITRANSBORDO = 0
                  AND nfc.UIDDETALLESINCRONIZADOR NOT IN (
                        SELECT UIDDETALLESINCRONIZADOR FROM SINCRONIZADOR.AJUSTEDEB
                  )
                  AND nfc.DTFECHAOPERACION < SYSDATE - 3 --> AQUI ES DE CUANTOS DIAS PARA ATRAS CONSIDERAR LOS REGISTROS DIFERNTES A ERROR 0 PARA TOMARLOS
                  AND  nfc.SINCIDENCIA not like 'DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN REPROCESOS
            AND  nfc.SINCIDENCIA not like 'SIM. DEB. PEND.%'-->CONDICION PARA EVITAR AGARRAR LOS QUE SEAN SIMULADOS DE REPROCESOS
      )
)

,
---ELEGIR UN REGISTRO POR DIA PARA EVITAR REPETIR VALIDADORES de los registros buenos
sin_repetir_validadores_REGISTROS_BUENOS AS (
    SELECT *
    FROM (
        SELECT
            r.*,
            ROW_NUMBER() OVER (
                PARTITION BY r.INUMEROTARJETA, TRUNC(r.DTFECHACREACION)
                ORDER BY r.UIDDETALLESINCRONIZADOR
            ) AS RN
        FROM base_raw_REPETIDOS_REGISTROS_BIEN_INCLUYENDO_PRIMERO_LOS_MALOS r
    )
    WHERE RN = 1
    --select * from base_raw;
)
,

--RECALCULADOS LOS INDICES DE ID CON EL CAMPO NEWID PARA OCUPARLO DENTRO DE LA VALIDACION DE TARJETAS CON EL NUMERO DE DEBITACIONES EXACTAS
Recalculando_identificadores_REGISTROS_BUENOS  as(
           select
                        (ROW_NUMBER() OVER (PARTITION BY srv.INUMEROTARJETA ORDER BY  srv.iERROR  DESC, srv.DTFECHAOPERACION ASC)) AS NewID,
             srV.*
             from sin_repetir_validadores_REGISTROS_BUENOS srv
),
tarjetas_validas_REGISTROS_BUENOS AS (
    SELECT INUMEROTARJETA
    FROM Recalculando_identificadores_REGISTROS_BUENOS
    WHERE NewID <= NUMDEBITACIONES
    GROUP BY INUMEROTARJETA, NUMDEBITACIONES
    HAVING COUNT(*) = NUMDEBITACIONES
)
--CONSULTA DE REGISTROS FINAL DONDE SOLO SE MUESTRAN LOS REGISTROS DE LAS TARJETAS QUE CUMPLAN CON TENER TODAS SUS DEBITACIONES COMO SE CALCULO
-- SE INCLUYE LOGICA PARA SACAR SI ES TRANSBORDO O PRECIO NORMAL ASI COMO TAMBIEN IDENTIFICAR EL TIPO DE TARIFA PARA SER CONSIDERADO

select
--UIDVALIDADOR,
UIDDETALLESINCRONIZADOR, DTFECHAOPERACION, INUMEROTARJETA,
STIPOTARIFA, DMONTOCOBRADO, SALDOMON, DSALDO, ICONTADORTRANSACCIONES,
DTFECHACREACION, LOADTRANSCOUNTER, IERROR, BPROCESADO, FECHAPROCESADO,
NVAFECHAPROCESAR, TRANSBORDO, SINCIDENCIA, NVODMONTOCOBRADO,BERROR
from (
--SECCION DE REGISTROS ERROR MAS LOS REGISTROS BUENOS TOMANDO PRIMERO LOS DE ERROR Y LUEGO LOS BUENOS DE FECHAS INICIALES CON REGISTROS SIN ERROR

        SELECT
            B.UIDVALIDADOR,
            --case when B.IERROR = 0 then 'Aqui_va_UUID' else B.UIDDETALLESINCRONIZADOR end as UIDDETALLESINCRONIZADOR ,
            B.UIDDETALLESINCRONIZADOR,
            B.DTFECHAOPERACION,
            B.INUMEROTARJETA,
            E.STIPOTARIFA,
            B.DMONTOCOBRADO,
            E.DSALDO AS SALDOMON,
            B.DSALDO,
            B.ICONTADORTRANSACCIONES,
            B.DTFECHACREACION,
            B.LOADTRANSCOUNTER,
            B.IERROR,
            0 AS BPROCESADO,
            SYSDATE AS FECHAPROCESADO,
            TO_DATE('29-09-2025', 'DD-MM-YYYY') + (B.DTFECHAOPERACION - TRUNC(B.DTFECHAOPERACION)) AS NVAFECHAPROCESAR,
            CASE
                WHEN NewID <= B.PARTE_ENTERA THEN 0
                ELSE 1
            END AS TRANSBORDO,
            case when B.IERROR = 0 then 'SIM. DEB. PEND. ' || TO_CHAR(B.DTFECHAOPERACION, 'YYYY-MM-DD') ELSE 'DEB. PEND. ' || TO_CHAR(B.DTFECHAOPERACION, 'YYYY-MM-DD') END AS SINCIDENCIA,
            CASE
                WHEN (CASE WHEN NewID <= B.PARTE_ENTERA THEN 0 ELSE 1 END) = 0
                    THEN CASE WHEN E.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END --> SI ES PARTE ENTERA ES COBRO NORMAL DE 12 EN TARIFAN NORMAL O 5 EN SOCIAL
                ELSE
                    CASE WHEN E.STIPOTARIFA = 'Tarifa General' THEN 6 ELSE 2.5 END --> SI ES PARTE DECIMAL ES TRANSBORDO CON COBRO DE 6 EN NORMAL O 2.5 EN SOCIAL
            END AS NVODMONTOCOBRADO,
            case when B.IERROR = 0 then 1 else 0 end AS BERROR

        FROM Recalculando_identificadores_REGISTROS_BUENOS B
        JOIN MONEDEROCONSULTAS.ESTADODECUENTA E ON E.INUMTARJETA = B.INUMEROTARJETA
        JOIN tarjetas_validas_REGISTROS_BUENOS V ON V.INUMEROTARJETA = B.INUMEROTARJETA
        WHERE NewID <= NUMDEBITACIONES -->
--         WHERE NewID <= 1 -->

        UNION
--SECCION DE SOLO REGISTROS TOMANDO LOS DE ERROR DIFERENTES A 0 QUE CUMPLEM EXACTO
        SELECT
            B.UIDVALIDADOR,
            B.UIDDETALLESINCRONIZADOR,
            B.DTFECHAOPERACION,
            B.INUMEROTARJETA,
            E.STIPOTARIFA,
            B.DMONTOCOBRADO,
            E.DSALDO AS SALDOMON,
            B.DSALDO,
            B.ICONTADORTRANSACCIONES,
            B.DTFECHACREACION,
            B.LOADTRANSCOUNTER,
            B.IERROR,
            0 AS BPROCESADO,
            SYSDATE AS FECHAPROCESADO,
            TO_DATE('29-09-2025', 'DD-MM-YYYY') + (B.DTFECHAOPERACION - TRUNC(B.DTFECHAOPERACION)) AS NVAFECHAPROCESAR,
            CASE
                WHEN NewID <= B.PARTE_ENTERA THEN 0
                ELSE 1
            END AS TRANSBORDO,
            'DEB. PEND. ' || TO_CHAR(B.DTFECHAOPERACION, 'YYYY-MM-DD') AS SINCIDENCIA,
            CASE
                WHEN (CASE WHEN NewID <= B.PARTE_ENTERA THEN 0 ELSE 1 END) = 0
                    THEN CASE WHEN E.STIPOTARIFA = 'Tarifa General' THEN 12 ELSE 5 END --> SI ES PARTE ENTERA ES COBRO NORMAL DE 12 EN TARIFAN NORMAL O 5 EN SOCIAL
                ELSE
                    CASE WHEN E.STIPOTARIFA = 'Tarifa General' THEN 6 ELSE 2.5 END --> SI ES PARTE DECIMAL ES TRANSBORDO CON COBRO DE 6 EN NORMAL O 2.5 EN SOCIAL
            END AS NVODMONTOCOBRADO,
            0 AS BERROR
        FROM Recalculando_identificadores B
        JOIN MONEDEROCONSULTAS.ESTADODECUENTA E ON E.INUMTARJETA = B.INUMEROTARJETA
        JOIN tarjetas_validas V ON V.INUMEROTARJETA = B.INUMEROTARJETA
        WHERE NewID <= NUMDEBITACIONES -->
--         WHERE NewID <= 1 -->
        ORDER BY INUMEROTARJETA, DTFECHAOPERACION DESC
);
--select * from SINCRONIZADOR.AJUSTEDEB where BPROCESADO = 0;
COMMIT;



